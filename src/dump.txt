
/*
static void cell_checker_main(t_game *game)
{
	cell_checker(game, paint_bg);
	cell_checker(game, paint_walls);
	cell_checker(game, paint_corners);
	cell_checker(game, paint_player);
}
*/

// Update map
// Clean map
// Redraw dan de map!

/*
prototype mlx_hook
int	mlx_hook(void *win_ptr, int x_event, int x_mask, int (*funct)(), void *param);
*/

/*
static void	draw_map(t_game *game)
{
	int	x;
	int	y;

	y = 0;
	//draw_bg(game);
	//draw_walls(game);
	while (y < (game->map.ntiles_rows))
	{
		x = 0;
		while (x < (game->map.ntiles_cols))
		{
			superimpose_tile(game, x, y);
			x = x + 1;
		}
		y = y + 1;
	}
}
*/

// Het gaat goed zodra ik 2 coordinaten heb.
// 1e is dan x
// 2e is dan y

/*
static void	check_map_borders(t_game *game)
{
	int	i;
	int	j;

	i = 0;
	while (i < game->map.ntiles_rows)
	{
		j = 0;
		if ((i == 0) || (i == (game->map.ntiles_rows) - 1))
		{
			while (j < game->map.ntiles_cols)
			{
				if (game->map.map[i][j] != '1')
					ft_map_failure(game, "Your map is not enclosed in borders");
				j++;
			}
		}
		else
		{
			if ((game->map.map[i][0] != '1') || \
			(game->map.map[i][game->map.ntiles_cols - 1] != '1'))
					ft_map_failure(game, "Your map is not enclosed in borders");
			j++;
		}
		i++;
	}
}
*/

/*
static void	check_map_contents2(t_game *game)
{
	if (game->map.content.players > 1)
		ft_map_failure(game, "You map has more than 1 player spawnpoint.");
	if (game->map.content.players < 1)
		ft_map_failure(game, "You map does not have 1 player spawnpoint.");
}
*/


/*
static void player_to_up(t_game *game)
{
	int posrow;
	int poscol;

	posrow = game->map.player_state.pos_row;
	poscol = game->map.player_state.pos_col;
	if (game->map.map[posrow - 1][poscol] != '0')
		return ;
	game->map.map[posrow - 1][poscol] = 'P';
	game->map.map[posrow][poscol] = '0';
	game->map.player_state.pos_row = game->map.player_state.pos_row - 1;
	game->map.player_state.pos_col = game->map.player_state.pos_col;
}

static void player_to_down(t_game *game)
{
	int posrow;
	int poscol;

	posrow = game->map.player_state.pos_row;
	poscol = game->map.player_state.pos_col;
	if (game->map.map[posrow + 1][poscol] != '0')
		return ;
	game->map.map[posrow + 1][poscol] = 'P';
	game->map.map[posrow][poscol] = '0';
	game->map.player_state.pos_row = game->map.player_state.pos_row + 1;
	game->map.player_state.pos_col = game->map.player_state.pos_col;
}

static void player_to_left(t_game *game)
{
	int posrow;
	int poscol;

	posrow = game->map.player_state.pos_row;
	poscol = game->map.player_state.pos_col;
	if (game->map.map[posrow][poscol - 1] != '0')
		return ;
	game->map.map[posrow][poscol - 1] = 'P';
	game->map.map[posrow][poscol] = '0';
	game->map.player_state.pos_row = game->map.player_state.pos_row + 0;
	game->map.player_state.pos_col = game->map.player_state.pos_col - 1;
}

static void player_to_right(t_game *game)
{
	int posrow;
	int poscol;

	posrow = game->map.player_state.pos_row;
	poscol = game->map.player_state.pos_col;
	if (game->map.map[posrow][poscol + 1] != '0')
		return ;
	game->map.map[posrow][poscol + 1] = 'P';
	game->map.map[posrow][poscol] = '0';
	game->map.player_state.pos_row = game->map.player_state.pos_row + 0;
	game->map.player_state.pos_col = game->map.player_state.pos_col + 1;
}
*/


// TODO: UPDATE MAP //

/*
int controller(int key, t_game *game)
{
	if (key == KEY_W)
		return (move_player_pos(game, 0, -1));
}
*/
/*
int move_player_pos(t_game *game, int x, int y)
{
	game->map.player_state.pos_row = game->map.player_state.pos_row + y;
	game->map.player_state.pos_col = game->map.player_state.pos_col + x;
	print_player_pos(game);
}
*/

	//cell_looper(game);
	//cell_looper_ptr(game, cell_player);
	//mlx_hook(game->mlx.win, 2, (1L<<0), input, (void *)&game); // 2 = key down, (1L<<0) KeyPressMask
	//mlx_loop(game->mlx.instance);
	//get_player_state_standalone(game);
	//printf("\nrow %d\n", game->map.player_state.pos_row);
	//printf("\ncol %d\n", game->map.player_state.pos_col);
	//printf("%d", game->map.player_state.tile_up);
	//printf("%d", game->map.player_state.tile_down);
	//cell_playerinfo(game);
	//print_player_state(game);
	//print_player_pos(game);
	//cell_player(game);
	//mlx_loop_hook(game->mlx.instance, update, game); // for each new frame it runs update()
	//mlx_loop(game->mlx.instance);

static void get_player_state_standalone(t_game *game)
{
	game->map.player.up = game->map.map[game->map.player.y-1][game->map.player.x];
	game->map.player.down = game->map.map[game->map.player.y+1][game->map.player.x];
	game->map.player.left = game->map.map[game->map.player.y][game->map.player.x - 1];
	game->map.player.right = game->map.map[game->map.player.y][game->map.player.x + 1];
}

static void move_up(t_game *game)
{
	if (game->map.player.up == 0)
	{
		game->map.player.y = game->map.player.y - 1;
		game->map.player.x = game->map.player.x;
		get_player_state_standalone(game);
		print_player_state(game);
	}
	else
	{
		printf("MOVEMENT NOT ALLOWED\n");
	}
}

/*
static void print_player_pos(t_game *game)
{
	printf("Player position:\n");
	printf("row: %d\n", game->map.player.y);
	printf("col: %d\n", game->map.player.x);
}
*/